package Exam;

public class Xiaohongshu {

    /*
    * 小红书校园招聘，某个部门恰好招聘了N*N位（N<=150）同学，为了让大家快速融入大家庭，我们玩儿了一个快速记人和问题速答的游戏，开始是每个人的自我介绍，然后介绍自己的家乡特点和爱好，之后是问题提问，每个人会被问到多个关于另一个同学相关的问题，答对加一分，打错负一分，在所有问答环节结束之后，HR统计在这些同学中，哪个子矩阵区域的同学总分最高，并对这个区域的同学进行鼓励。



输入描述
输入第一行为整数N，第二行为N*N个整数组成(空格分割)，代表同学的答题得分的矩阵（行优先，第一行N个数，接着第二行N个数，以此类推）。

输出描述
队伍中一个得分最高的子队伍得分


样例输入
3
1 2 -3 3 4 -5 -5 -6 -7
样例输出
10
    *
    *
    * */


    /*
    *
    *
    *
    * 题目描述：
段式回文类似于回文，最小的单位可以是多个字符而不仅是单个字母 例如：一般的回文字符串形式如“level、noon、civic”，而“gotogo”不是，但如果我们把“gotogo”分为“go”、“to”、“go”三段，则可以认为“go to go”是段式回文

给定一个字符串s（s仅由小写英文字母组成，且s长度<= 30），请将s分割成一些子串，使每个子串都是段式回文。返回s所有可能的分割方案的个数

例如gotogo，可有6种分隔方案，即：[g, o, t, o, g, o], [g, o, t, ogo], [g, oto, g, o], [g, otogo], [gotog, o], [gotogo]*/



    /*
    *
    * 薯队长看到了一颗神奇的树，树上有在每个结点上都住的一只蜗牛，树的结点数是N(N<=10000)。假设每只蜗牛的爬行速度都是一样的，树的每条边代表着蜗牛通过需要的时间（不超过1000）。

如果在两个结点上的蜗牛到达对方的时间不超过K（K <= 10^9)，我们认为这两个蜗牛是好朋友。现在给定蜗牛们居住的树，薯队长想知道蜗牛们有多少对好朋友。

对于30%的数据，N<=20

对于50%的数据，N<=2000

对于100%的数据，N<=10000



输入描述
第一行两个正整数N, K。

之后一行有3 * (N-1)个整数，每三个正整数a,b,c代表从结点a到结点b有一个边，时间为c

输入即a[0] b[0] c[0] a[1] b[1] c[1] ....

注意结点的编号不一定是从0开始，但树一定是合法的
    * */

}
